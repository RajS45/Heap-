1.Heapify Algorithm.
class Solution {
    public void heapify(int[] nums, int ind, int val) {
        if (nums[ind] < val) {
            nums[ind] = val;
            heapifyUp(nums, ind);
        } else {
            nums[ind] = val;
            heapifyDown(nums, ind);
        }
    }
    public void heapifyDown(int[] arr, int ind) {
        int n = arr.length;
        int largest = ind; 
        int leftChild_ind = 2 * ind + 1;
        int rightChild_ind = 2 * ind + 2;
        if (leftChild_ind < n && arr[leftChild_ind] > arr[largest]) {
            largest = leftChild_ind;
        }
        if (rightChild_ind < n && arr[rightChild_ind] > arr[largest]) {
            largest = rightChild_ind;
        }
        if (largest != ind) {
            int temp = arr[ind];
            arr[ind] = arr[largest];
            arr[largest] = temp;
            heapifyDown(arr, largest); 
        }
    }
    public void heapifyUp(int[] arr, int ind) {
        if (ind > 0) {
            int parent_ind = (ind - 1) / 2;
            if (arr[ind] > arr[parent_ind]) {
                int temp = arr[ind];
                arr[ind] = arr[parent_ind];
                arr[parent_ind] = temp;
                heapifyUp(arr, parent_ind);
            }
        }
    }
}

2.Build heap from a given Array
class Solution {
    public void buildMinHeap(int[] nums) {
        int n = nums.length;
        for (int i = (n / 2) - 1; i >= 0; i--) {
            heapifyDown(nums, i, n);
        }
    }
    public void heapifyDown(int[] arr, int ind, int n) {
        int smallest = ind;
        int leftChild = 2 * ind + 1;
        int rightChild = 2 * ind + 2;
        if (leftChild < n && arr[leftChild] < arr[smallest]) {
            smallest = leftChild;
        }
        if (rightChild < n && arr[rightChild] < arr[smallest]) {
            smallest = rightChild;
        }
        if (smallest != ind) {
            int temp = arr[ind];
            arr[ind] = arr[smallest];
            arr[smallest] = temp;
            heapifyDown(arr, smallest, n);
        }
    }
}
3.Implement Min Heap. 
import java.util.*;
class Solution {
    private List<Integer> arr = new ArrayList<>(); 
    private int count = 0;
    private void heapifyUp(List<Integer> arr, int ind) {
        int parentInd = (ind - 1)/2; 
        if(ind > 0 && arr.get(ind) < arr.get(parentInd)) {
            int temp = arr.get(ind);
            arr.set(ind, arr.get(parentInd));
            arr.set(parentInd, temp);
            heapifyUp(arr, parentInd);
        } 
    }    
    private void heapifyDown(List<Integer> arr, int ind) {
        int n = arr.size(); 
        int smallestInd = ind; 
        int leftChildInd = 2*ind + 1;
        int rightChildInd = 2*ind + 2;        
        if(leftChildInd < n && arr.get(leftChildInd) < arr.get(smallestInd)) 
            smallestInd = leftChildInd;
        if(rightChildInd < n && arr.get(rightChildInd) < arr.get(smallestInd)) 
            smallestInd = rightChildInd;
        if(smallestInd != ind) {
            int temp = arr.get(smallestInd);
            arr.set(smallestInd, arr.get(ind));
            arr.set(ind, temp);
            heapifyDown(arr, smallestInd);
        }
    }    
    public void initializeHeap() {
        arr.clear();
        count = 0;
    }    
    public void insert(int key) {
        arr.add(key);        
        heapifyUp(arr, count);
        count = count + 1;
    }      
    public void changeKey(int index, int new_val) {
        if(arr.get(index) > new_val) {
            arr.set(index, new_val);
            heapifyUp(arr, index);
        } else {
            arr.set(index, new_val);
            heapifyDown(arr, index);
        }
    }  
    public void extractMin() {
        int temp = arr.get(count - 1);
        arr.set(count - 1, arr.get(0));
        arr.set(0, temp);
        arr.remove(count - 1);
        count = count - 1;
        if(count > 0) {
            heapifyDown(arr, 0);
        }
    } 
    public boolean isEmpty() {
        return (count == 0);
    } 
    public int getMin() {
        return arr.get(0);
    }
    public int heapSize() {
        return count;
    }
}
4.Implement Max Heap.
import java.util.*;
class Solution {
    int cnt = 0;
    List<Integer> arr = new ArrayList<>();
    private void heapifyDown(List<Integer> arr, int ind) {
        int n = arr.size();
        int largest = ind;
        int leftChild = 2 * ind + 1;
        int rightChild = 2 * ind + 2;

        if (leftChild < n && arr.get(largest) < arr.get(leftChild)) {
            largest = leftChild;
        }
        if (rightChild < n && arr.get(largest) < arr.get(rightChild)) {
            largest = rightChild;
        }

        if (largest != ind) {
            int temp = arr.get(largest);
            arr.set(largest, arr.get(ind));
            arr.set(ind, temp);
            heapifyDown(arr, largest); 
        }
    }
    private void heapifyUp(List<Integer> arr, int ind) {
        int parentInd = (ind - 1) / 2;
        if (ind > 0 && arr.get(ind) > arr.get(parentInd)) {
            int temp = arr.get(parentInd);
            arr.set(parentInd, arr.get(ind));
            arr.set(ind, temp);
            heapifyUp(arr, parentInd);
        }
    }
    public void initializeHeap() {
        arr.clear();
        cnt = 0;
    }
    public void insert(int key) {
        arr.add(key);
        heapifyUp(arr, cnt); 
        cnt++;
    }
    public void changeKey(int ind, int newVal) {
        if (newVal > ind) {
            arr.set(ind , newVal);
            heapifyUp(arr, ind);
        } else {
            arr.set(ind , newVal);
            heapifyDown(arr, ind);
        }
    }
    public void extractMax() {
        if (cnt == 0) return;
        int temp = arr.get(cnt - 1);
        arr.set(cnt - 1, arr.get(0));
        arr.set(0, temp);
        arr.remove(cnt - 1);
        cnt--;
        if (cnt > 0) {
            heapifyDown(arr, 0);
        }
    }
    public boolean isEmpty() {
        return cnt == 0;
    }

    public int getMax() {
        return arr.get(0);
    }

    public int heapSize() {
        return cnt;
    }
}
5.Check if an array represents a min heap
class Solution {
    public boolean isHeap(int[] nums) {
       int n = nums.length;
       for(int i = (n/2) - 1;i>=0;i--){
        int leftChild = 2*i+1;
        int rightChild = 2*i+2;
        if(leftChild < n && nums[leftChild] < nums[i]){
            return false;
        }
        if(rightChild < n && nums[rightChild] < nums[i]){
            return false;
        }
       }
       return true;
    }
    public static void main (String [] args){
        int [] arr = {12,1,34,5,2};
        Solution sol = new Solution();
        sol.isHeap(arr);
    }
}
6.Convert Min Heap to Max Heap
class Solution {
    private void heapifyDown(int[] arr, int ind) {
        int n = arr.length;
        int largestInd = ind;
        int leftChildInd = 2 * ind + 1;
        int rightChildInd = 2 * ind + 2;
        if (leftChildInd < n && arr[leftChildInd] > arr[largestInd]) {
            largestInd = leftChildInd;
        }
        if (rightChildInd < n && arr[rightChildInd] > arr[largestInd]) {
            largestInd = rightChildInd;
        }
        if (largestInd != ind) {
            int temp = arr[largestInd];
            arr[largestInd] = arr[ind];
            arr[ind] = temp;
            heapifyDown(arr, largestInd);
        }
    }
    public int[] minToMaxHeap(int[] nums) {
        int n = nums.length;
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapifyDown(nums, i);
        }
        return nums;
    }
}
7.Heap Sort.
class Solution {
    public void heapify(int []nums , int ind , int n){
        int largest = ind;
        int leftChild = 2*ind+1;
        int rightChild = 2*ind+2;
        if(leftChild < n && nums[leftChild] > nums[largest]){
            largest = leftChild;
        }
        if(rightChild < n && nums[rightChild] > nums[largest]){
            largest = rightChild;
        }
        if(largest != ind){
            int temp = nums[largest];
            nums[largest] = nums[ind];
            nums[ind] = temp;
            heapify(nums , largest , n);
        }
    }
    public void buildMaxHeap(int []nums){
        int n = nums.length;
        for(int i=n/2 - 1 ;i>=0;i--){
            heapify(nums, i , n);
        }
    }
    public void heapSort(int []nums){
        int n = nums.length;
        buildMaxHeap(nums);
        for(int i=n-1;i>0;i--){
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            heapify(nums , 0, i);
        }
    }
}
8. Kth largest element in a stream of running integers.
class KthLargest {
    private PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    private int k;
    public KthLargest(int k, int[] nums) {
        this.k = k;
        for (int num : nums) {
            minHeap.offer(num);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
    }
    public int add(int val) {
        minHeap.offer(val);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
    public static void main(String []args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int []arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int k = sc.nextInt();
        KthLargest sol = new KthLargest();
        int [] res = sol.KthLargest(arr , k);
        for(int i=0;i<res.length; i++){
            System.out.println(res[i]);
        }
    }
}
